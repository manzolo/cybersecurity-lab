#cloud-config
package_update: true
package_upgrade: true
packages:
  - python3
  - python3-pip
  - python3-venv
  - ufw
  - htop
  - net-tools
  - tcpdump
  - apache2
  - mysql-server

users:
  - name: labuser
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    shell: /bin/bash
    ssh_authorized_keys:
      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC... # Replace with your SSH key

write_files:
  - path: /opt/vulnerable-server.py
    content: |
      #!/usr/bin/env python3
      """
      Vulnerable TCP Server for cybersecurity testing
      """
      import socket
      import threading
      import time
      import logging
      import os
      import subprocess
      from datetime import datetime
      
      # Logging configuration
      logging.basicConfig(
          level=logging.INFO,
          format='%(asctime)s - %(levelname)s - %(message)s',
          handlers=[
              logging.FileHandler('/var/log/vulnerable-server.log'),
              logging.StreamHandler()
          ]
      )
      logger = logging.getLogger(__name__)
      
      class VulnerableServer:
          def __init__(self, host="0.0.0.0", port=9000):
              self.host = host
              self.port = port
              self.running = False
              self.connections = []
              self.connection_count = 0
          
          def handle_client(self, conn, addr):
              self.connection_count += 1
              conn_id = self.connection_count
              logger.info(f"[Connection {conn_id}] New connection from {addr}")
              
              try:
                  # Send welcome message
                  welcome = f"Welcome to Vulnerable Server v1.0\\nConnection ID: {conn_id}\\nType 'help' for commands\\n> "
                  conn.sendall(welcome.encode())
                  
                  while self.running:
                      data = conn.recv(1024).decode('utf-8').strip()
                      if not data:
                          break
                      
                      logger.info(f"[Connection {conn_id}] Command: {data}")
                      
                      if data.lower() == "help":
                          response = """Available commands:
      - help: Show this message
      - info: Server information
      - time: Current time
      - status: System status
      - whoami: Current user
      - uptime: System uptime
      - echo <msg>: Echo message
      - quit: Disconnect
      > """
                      elif data.lower() == "info":
                          response = f"Server: Vulnerable Test Server v1.0\\nTime: {datetime.now()}\\nConnections: {len(self.connections)}\\n> "
                      elif data.lower() == "time":
                          response = f"Server time: {time.ctime()}\\n> "
                      elif data.lower() == "status":
                          response = f"System load: {os.getloadavg()}\\nUptime: {subprocess.check_output(['uptime'], text=True).strip()}\\n> "
                      elif data.lower() == "whoami":
                          response = f"Current user: {os.getenv('USER', 'unknown')}\\nUID: {os.getuid()}\\n> "
                      elif data.lower() == "uptime":
                          uptime = subprocess.check_output(['uptime'], text=True).strip()
                          response = f"Uptime: {uptime}\\n> "
                      elif data.lower().startswith("echo "):
                          msg = data[5:]
                          response = f"Echo: {msg}\\n> "
                      elif data.lower() == "quit":
                          response = "Goodbye!\\n"
                          conn.sendall(response.encode())
                          break
                      else:
                          response = f"Unknown command: '{data}'. Use 'help' for available commands\\n> "
                      
                      conn.sendall(response.encode())
                      
              except Exception as e:
                  logger.error(f"[Connection {conn_id}] Error: {e}")
              finally:
                  conn.close()
                  logger.info(f"[Connection {conn_id}] Disconnected")
          
          def start(self):
              self.running = True
              with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
                  server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                  server_socket.bind((self.host, self.port))
                  server_socket.listen(10)
                  
                  logger.info(f"Vulnerable server listening on {self.host}:{self.port}")
                  
                  try:
                      while self.running:
                          conn, addr = server_socket.accept()
                          self.connections.append(conn)
                          client_thread = threading.Thread(
                              target=self.handle_client, 
                              args=(conn, addr)
                          )
                          client_thread.daemon = True
                          client_thread.start()
                  except KeyboardInterrupt:
                      logger.info("Server stopped by user")
                  finally:
                      self.running = False
      
      if __name__ == "__main__":
          server = VulnerableServer()
          server.start()
    permissions: '0755'

  - path: /opt/web-server.py
    content: |
      #!/usr/bin/env python3
      """
      Simple HTTP server with vulnerabilities for testing
      """
      from http.server import HTTPServer, BaseHTTPRequestHandler
      import urllib.parse
      import os
      import logging
      
      # Logging configuration
      logging.basicConfig(
          level=logging.INFO,
          format='%(asctime)s - %(levelname)s - %(message)s',
          handlers=[
              logging.FileHandler('/var/log/vulnerable-web.log'),
              logging.StreamHandler()
          ]
      )
      logger = logging.getLogger(__name__)
      
      class VulnerableHTTPHandler(BaseHTTPRequestHandler):
          def do_GET(self):
              parsed_path = urllib.parse.urlparse(self.path)
              query = urllib.parse.parse_qs(parsed_path.query)
              
              if parsed_path.path == '/':
                  self.send_response(200)
                  self.send_header('Content-type', 'text/html')
                  self.end_headers()
                  
                  html = """
                  <html><body>
                  <h1>Vulnerable Web Server</h1>
                  <p>Test endpoints:</p>
                  <ul>
                      <li><a href="/info">Server Info</a></li>
                      <li><a href="/echo?msg=hello">Echo Test</a></li>
                      <li><a href="/file?name=test.txt">File Access</a></li>
                  </ul>
                  </body></html>
                  """
                  self.wfile.write(html.encode())
                  
              elif parsed_path.path == '/info':
                  self.send_response(200)
                  self.send_header('Content-type', 'text/plain')
                  self.end_headers()
                  info = f"Server: VulnWeb\\nTime: {os.popen('date').read()}"
                  self.wfile.write(info.encode())
                  
              elif parsed_path.path == '/echo':
                  msg = query.get('msg', ['No message'])[0]
                  self.send_response(200)
                  self.send_header('Content-type', 'text/html')
                  self.end_headers()
                  # Vulnerable to XSS
                  response = f"<html><body><h1>Echo: {msg}</h1></body></html>"
                  self.wfile.write(response.encode())
                  
              elif parsed_path.path == '/file':
                  filename = query.get('name', [''])[0]
                  self.send_response(200)
                  self.send_header('Content-type', 'text/plain')
                  self.end_headers()
                  # Vulnerable to directory traversal
                  try:
                      with open(f"/tmp/{filename}", 'r') as f:
                          content = f.read()
                      self.wfile.write(content.encode())
                  except:
                      self.wfile.write(b"File not found")
                      
              else:
                  self.send_response(404)
                  self.end_headers()
                  self.wfile.write(b"Not Found")
          
          def log_message(self, format, *args):
              logger.info(f"{self.client_address[0]} - {format % args}")
      
      if __name__ == "__main__":
          server = HTTPServer(('0.0.0.0', 8080), VulnerableHTTPHandler)
          logger.info("Starting HTTP server on port 8080")
          server.serve_forever()
    permissions: '0755'

  - path: /etc/systemd/system/vulnerable-server.service
    content: |
      [Unit]
      Description=Vulnerable TCP Server for Cybersecurity Lab
      After=network.target
      
      [Service]
      Type=simple
      ExecStart=/usr/bin/python3 /opt/vulnerable-server.py
      Restart=always
      RestartSec=5
      User=root
      StandardOutput=syslog
      StandardError=syslog
      SyslogIdentifier=vulnerable-server
      
      [Install]
      WantedBy=multi-user.target

  - path: /etc/systemd/system/vulnerable-web.service
    content: |
      [Unit]
      Description=Vulnerable Web Server
      After=network.target
      
      [Service]
      Type=simple
      ExecStart=/usr/bin/python3 /opt/web-server.py
      Restart=always
      RestartSec=5
      User=root
      StandardOutput=syslog
      StandardError=syslog
      SyslogIdentifier=vulnerable-web
      
      [Install]
      WantedBy=multi-user.target

  - path: /opt/monitor.sh
    content: |
      #!/bin/bash
      # Enhanced monitoring script for the target
      LOG_FILE="/var/log/target-monitor.log"
      
      while true; do
          echo "$(date -Is) - === MONITORING SNAPSHOT ===" >> "$LOG_FILE"
          echo "Active TCP connections:" >> "$LOG_FILE"
          ss -tuln >> "$LOG_FILE"
          echo "Network processes:" >> "$LOG_FILE"
          lsof -i >> "$LOG_FILE"
          echo "System load:" >> "$LOG_FILE"
          uptime >> "$LOG_FILE"
          echo "Memory usage:" >> "$LOG_FILE"
          free -h >> "$LOG_FILE"
          echo "---" >> "$LOG_FILE"
          sleep 30
      done
    permissions: '0755'

  - path: /etc/systemd/system/target-monitor.service
    content: |
      [Unit]
      Description=Target Monitor
      After=network.target

      [Service]
      ExecStart=/opt/monitor.sh
      Restart=always
      User=root

      [Install]
      WantedBy=multi-user.target

  - path: /tmp/test.txt
    content: |
      This is a test file for directory traversal testing.
      Secret: FLAG{directory_traversal_works}
    permissions: '0644'

runcmd:
  # Create log files with proper permissions
  - [touch, /var/log/vulnerable-server.log]
  - [chown, root:root, /var/log/vulnerable-server.log]
  - [chmod, 664, /var/log/vulnerable-server.log]
  - [touch, /var/log/vulnerable-web.log]
  - [chown, root:root, /var/log/vulnerable-web.log]
  - [chmod, 664, /var/log/vulnerable-web.log]
  - [touch, /var/log/target-monitor.log]
  - [chown, root:root, /var/log/target-monitor.log]
  - [chmod, 664, /var/log/target-monitor.log]
  
  # MySQL basic setup
  - [mysql, -e, "CREATE DATABASE vuln_db;"]
  - [mysql, -e, "CREATE USER 'labuser'@'localhost' IDENTIFIED BY 'labpassword';"]
  - [mysql, -e, "GRANT ALL PRIVILEGES ON vuln_db.* TO 'labuser'@'localhost';"]
  - [mysql, -e, "FLUSH PRIVILEGES;"]
  
  # Disable Apache2 to avoid port conflicts
  - [systemctl, disable, apache2]
  - [systemctl, stop, apache2]
  
  # System setup
  - [systemctl, daemon-reload]
  - [systemctl, enable, vulnerable-server.service]
  - [systemctl, start, vulnerable-server.service]
  - [systemctl, enable, vulnerable-web.service]
  - [systemctl, start, vulnerable-web.service]
  
  # Firewall configuration
  - [ufw, --force, reset]
  - [ufw, default, deny, incoming]
  - [ufw, default, allow, outgoing]
  - [ufw, allow, OpenSSH]
  - [ufw, allow, 9000/tcp]
  - [ufw, allow, 8080/tcp]
  - [ufw, --force, enable]
  
  # Enable and start the monitor
  - [systemctl, enable, target-monitor.service]
  - [systemctl, start, target-monitor.service]

final_message: "TARGET VM configured: TCP server on port 9000, HTTP server on port 8080, MySQL database created"